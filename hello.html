<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KAMBA Forum - Chat</title>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    /* [Previous CSS styles remain exactly the same] */
  </style>
</head>
<body>
  <!-- [Previous HTML structure remains exactly the same] -->

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { 
      getAuth, 
      onAuthStateChanged, 
      signOut,
      updateProfile
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
    import { 
      getFirestore, 
      doc, 
      getDoc, 
      setDoc, 
      updateDoc, 
      collection, 
      onSnapshot, 
      query, 
      orderBy, 
      addDoc,
      serverTimestamp,
      getDocs,
      where
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
    import { 
      getStorage,
      ref,
      uploadBytes,
      getDownloadURL
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-storage.js";

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyCW2RJIku0JLJZTUu0YA9yKO8zjtX29fAo",
      authDomain: "muah-feed.firebaseapp.com",
      databaseURL: "https://muah-feed-default-rtdb.firebaseio.com",
      projectId: "muah-feed",
      storageBucket: "muah-feed.appspot.com",
      messagingSenderId: "442314397706",
      appId: "1:442314397706:web:a69e3958257fb13b3667f3",
      measurementId: "G-S86S229F1T"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // DOM elements
    const chatMessages = document.getElementById('chat-messages');
    const messageInput = document.getElementById('message-input');
    const emojiBtn = document.getElementById('emoji-btn');
    const emojiPicker = document.querySelector('.emoji-picker');
    const uploadImageBtn = document.getElementById('upload-image-btn');
    const uploadImageInput = document.getElementById('upload-image-input');
    const loadingOverlay = document.getElementById('loading-overlay');
    const fullscreenViewer = document.getElementById('fullscreen-image-viewer');
    const fullscreenImg = fullscreenViewer.querySelector('img');
    const fullscreenCloseBtn = fullscreenViewer.querySelector('.close-btn');
    const noSongNotification = document.getElementById('no-song-notification');
    const dismissNoSongBtn = document.getElementById('dismiss-no-song-btn');
    const setSongLink = document.getElementById('set-song-link');
    const settingsCog = document.querySelector('.fa-cog');
    const searchInput = document.querySelector('#header input[type="search"]');
    const serverIcons = document.querySelectorAll('.server-icon');
    const channelItems = document.querySelectorAll('.list-item');

    // User data
    let currentUser = null;
    let userData = null;
    let replyToMessageId = null;
    let currentChannel = 'general';
    let currentServer = 'KAMBA';

    // Constants
    const emojis = ['ðŸ˜€','ðŸ˜‚','ðŸ¥°','ðŸ˜Ž','ðŸ˜¢','ðŸ˜¡','ðŸ¤”','ðŸ¤¯','ðŸ¥³','ðŸ˜´','â¤ï¸','ðŸ‘','ðŸ‘Ž','ðŸ”¥','ðŸŽ‰','ðŸ’¯','ðŸ¤£','ðŸ˜','ðŸ˜­','ðŸ™„'];
    const MAX_IMAGE_SIZE_MB = 6;
    const MAX_TOTAL_UPLOAD_MB = 6;
    const NO_SONG_DISMISS_KEY = 'noSongDismissedTime';

    // Initialize audio for background song
    const backgroundAudio = new Audio();
    backgroundAudio.loop = true;

    // --- AUTH STATE MANAGEMENT ---
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = 'sign.html';
        return;
      }
      
      currentUser = user;
      showLoading();
      
      try {
        // Load or create user data
        await loadOrCreateUserData();
        
        // Update UI with user data
        updateUserUI();
        
        // Check and setup background song
        checkBackgroundSong();
        
        // Load initial data
        loadInitialData();
        
      } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize. Please refresh the page.');
      } finally {
        hideLoading();
      }

      // Setup event listeners
      setupEventListeners();
    });

    // Load or create user data in Firestore
    async function loadOrCreateUserData() {
      const userDocRef = doc(db, 'Kamba_users', currentUser.email);
      const userSnap = await getDoc(userDocRef);
      
      if (userSnap.exists()) {
        userData = userSnap.data();
        
        // Migrate old data if needed
        if (!userData.sparks) {
          userData.sparks = 0;
          await updateDoc(userDocRef, { sparks: 0 });
        }
        if (!userData.accountStatus) {
          userData.accountStatus = 'green';
          await updateDoc(userDocRef, { accountStatus: 'green' });
        }
      } else {
        // Create new user document
        userData = { 
          name: currentUser.displayName || currentUser.email.split('@')[0],
          phone: '',
          accountStatus: 'green',
          sparks: 0,
          songUrl: '',
          songVolume: 50,
          agreedTerms: false,
          lastSeen: serverTimestamp(),
          createdAt: serverTimestamp()
        };
        await setDoc(userDocRef, userData);
      }
      
      // Check and prompt for terms agreement
      if (!userData.agreedTerms) {
        const agreed = confirm('Do you agree to the terms and conditions?');
        if (agreed) {
          await updateDoc(userDocRef, { agreedTerms: true });
          userData.agreedTerms = true;
        } else {
          await signOut(auth);
          return;
        }
      }
    }

    // Update UI with user data
    function updateUserUI() {
      // Update user section in sidebar
      const userSection = document.querySelector('.user-section .user-name');
      if (userSection) {
        userSection.textContent = userData.name || currentUser.email.split('@')[0];
      }
      
      // Update user avatar
      const userAvatar = document.querySelector('.user-section .user-avatar');
      if (userAvatar) {
        if (currentUser.photoURL) {
          userAvatar.innerHTML = `<img src="${currentUser.photoURL}" alt="User avatar">`;
        } else {
          const initial = (userData.name || currentUser.email[0]).toUpperCase();
          userAvatar.innerHTML = `<span>${initial}</span>`;
          userAvatar.className = `user-avatar ${userData.accountStatus || 'green'}`;
        }
      }
      
      // Update channel header
      updateChannelHeader();
    }

    // Update channel header with current channel info
    function updateChannelHeader() {
      const channelName = document.querySelector('.channel-name');
      const channelTopic = document.querySelector('.channel-topic');
      
      if (channelName) channelName.textContent = `#${currentChannel}`;
      if (channelTopic) {
        channelTopic.textContent = getChannelTopic(currentChannel);
      }
    }

    // Get channel topic based on channel name
    function getChannelTopic(channel) {
      const topics = {
        'general': 'Welcome to the general chat!',
        'announcements': 'Official announcements from KAMBA',
        'welcome': 'Introduce yourself to the community',
        'help': 'Get help with KAMBA Forum'
      };
      return topics[channel] || `Welcome to ${channel} channel`;
    }

    // Check and setup background song
    function checkBackgroundSong() {
      if (userData.songUrl) {
        backgroundAudio.src = userData.songUrl;
        backgroundAudio.volume = (userData.songVolume || 50) / 100;
        backgroundAudio.play().catch(e => console.log('Audio play failed:', e));
        noSongNotification.style.display = 'none';
      } else {
        checkNoSongNotification();
      }
    }

    // Check and show no song notification
    function checkNoSongNotification() {
      const dismissedTime = localStorage.getItem(NO_SONG_DISMISS_KEY);
      const now = Date.now();
      if (!userData.songUrl && (!dismissedTime || now - dismissedTime > 10 * 60 * 60 * 1000)) {
        noSongNotification.style.display = 'flex';
      } else {
        noSongNotification.style.display = 'none';
      }
    }

    // Load initial data
    function loadInitialData() {
      // Load messages for current channel
      loadMessages();
      
      // Load servers and channels
      loadServersAndChannels();
      
      // Load user list
      loadUserList();
    }

    // Load messages for current channel
    function loadMessages() {
      const messagesRef = collection(db, 'servers', currentServer, 'channels', currentChannel, 'messages');
      const messagesQuery = query(messagesRef, orderBy('timestamp', 'asc'));
      
      onSnapshot(messagesQuery, (snapshot) => {
        chatMessages.innerHTML = '';
        let lastUserId = null;
        let messageGroup = null;
        
        snapshot.forEach((doc) => {
          const msg = doc.data();
          const isSameUser = msg.userId === lastUserId;
          lastUserId = msg.userId;
          
          if (!isSameUser || !messageGroup) {
            messageGroup = document.createElement('div');
            messageGroup.className = 'message-group';
            chatMessages.appendChild(messageGroup);
          }
          
          const messageEl = createMessageElement(doc.id, msg);
          messageGroup.appendChild(messageEl);
        });
        
        scrollToBottom();
      }, (error) => {
        console.error('Error listening to messages:', error);
        showError('Failed to load messages. Please refresh the page.');
      });
    }

    // Load servers and channels
    async function loadServersAndChannels() {
      // In a real app, you would fetch these from Firestore
      // For demo purposes, we're using the static HTML content
      
      // Add click handlers to server icons
      serverIcons.forEach(icon => {
        icon.addEventListener('click', () => {
          serverIcons.forEach(i => i.classList.remove('active'));
          icon.classList.add('active');
          currentServer = icon.getAttribute('title') || 'KAMBA';
          loadMessages();
        });
      });
      
      // Add click handlers to channel items
      channelItems.forEach(item => {
        item.addEventListener('click', () => {
          channelItems.forEach(i => i.classList.remove('active'));
          item.classList.add('active');
          currentChannel = item.textContent.toLowerCase();
          updateChannelHeader();
          loadMessages();
        });
      });
    }

    // Load user list
    async function loadUserList() {
      // In a real app, you would fetch users from Firestore
      // For demo purposes, we're using the static HTML content
    }

    // Create message DOM element
    function createMessageElement(id, msg) {
      const username = msg.name || (msg.userId ? msg.userId.split('@')[0] : 'Unknown');
      const status = msg.accountStatus || 'green';
      
      const el = document.createElement('div');
      el.className = 'message';
      el.dataset.id = id;

      // Avatar
      const avatarEl = document.createElement('div');
      avatarEl.className = `message-avatar ${status}`;
      
      if (msg.avatarUrl) {
        avatarEl.innerHTML = `<img src="${msg.avatarUrl}" alt="${username}'s avatar">`;
      } else {
        const initial = username[0].toUpperCase();
        avatarEl.innerHTML = `<div class="avatar-placeholder">${initial}</div>`;
      }
      el.appendChild(avatarEl);

      // Message content
      const contentEl = document.createElement('div');
      contentEl.className = 'message-content';
      
      // Message header (username, timestamp)
      const headerEl = document.createElement('div');
      headerEl.className = 'message-header';
      
      const usernameEl = document.createElement('span');
      usernameEl.className = `message-username ${status}`;
      usernameEl.textContent = username;
      headerEl.appendChild(usernameEl);
      
      if (msg.isBot) {
        const botTag = document.createElement('span');
        botTag.className = 'message-bot-tag';
        botTag.textContent = 'BOT';
        headerEl.appendChild(botTag);
      }
      
      const timestampEl = document.createElement('span');
      timestampEl.className = 'message-timestamp';
      timestampEl.textContent = formatTimestamp(msg.timestamp);
      headerEl.appendChild(timestampEl);
      
      contentEl.appendChild(headerEl);

      // Reply to (if any)
      if (msg.replyTo) {
        const replyEl = document.createElement('div');
        replyEl.className = 'message-reply';
        
        const replyUsername = document.createElement('span');
        replyUsername.className = 'message-reply-username';
        replyUsername.textContent = msg.replyToName || 'Unknown';
        replyEl.appendChild(replyUsername);
        
        const replyContent = document.createElement('span');
        replyContent.className = 'message-reply-content';
        replyContent.textContent = msg.replyToText || '';
        replyEl.appendChild(replyContent);
        
        contentEl.appendChild(replyEl);
      }

      // Message text
      const textEl = document.createElement('div');
      textEl.className = 'message-text';
      textEl.textContent = msg.text || '';
      contentEl.appendChild(textEl);

      // Images
      if (msg.images && msg.images.length > 0) {
        const attachmentsEl = document.createElement('div');
        attachmentsEl.className = 'message-attachments';
        
        msg.images.forEach((imgUrl) => {
          const attachmentEl = document.createElement('div');
          attachmentEl.className = 'message-attachment';
          
          const img = document.createElement('img');
          img.src = imgUrl;
          img.alt = 'Chat image';
          img.addEventListener('click', () => openFullscreenImage(imgUrl));
          attachmentEl.appendChild(img);
          
          const downloadEl = document.createElement('div');
          downloadEl.className = 'message-attachment-download';
          downloadEl.innerHTML = '<i class="fas fa-download"></i>';
          downloadEl.addEventListener('click', (e) => {
            e.stopPropagation();
            downloadImage(imgUrl);
          });
          attachmentEl.appendChild(downloadEl);
          
          attachmentsEl.appendChild(attachmentEl);
        });
        
        contentEl.appendChild(attachmentsEl);
      }

      // Message actions
      const actionsEl = document.createElement('div');
      actionsEl.className = 'message-actions';
      
      const replyBtn = document.createElement('i');
      replyBtn.className = 'message-action fas fa-reply';
      replyBtn.title = 'Reply';
      replyBtn.addEventListener('click', () => {
        replyToMessageId = id;
        messageInput.focus();
        messageInput.value = `@${username} `;
      });
      actionsEl.appendChild(replyBtn);
      
      // Add like button for projects (only in project channels)
      if (currentChannel.includes('project-')) {
        const likeBtn = document.createElement('i');
        likeBtn.className = 'message-action fas fa-heart';
        likeBtn.title = 'Like';
        likeBtn.addEventListener('click', () => likeProject(id));
        actionsEl.appendChild(likeBtn);
        
        const likeCount = document.createElement('span');
        likeCount.className = 'like-count';
        likeCount.textContent = msg.likes ? msg.likes.length : 0;
        actionsEl.appendChild(likeCount);
      }
      
      el.appendChild(contentEl);
      el.appendChild(actionsEl);

      return el;
    }

    // Like a project (adds Sparks to the creator)
    async function likeProject(messageId) {
      if (!currentUser) return;
      
      try {
        const messageRef = doc(db, 'servers', currentServer, 'channels', currentChannel, 'messages', messageId);
        const messageSnap = await getDoc(messageRef);
        
        if (messageSnap.exists()) {
          const messageData = messageSnap.data();
          const likes = messageData.likes || [];
          
          // Check if user already liked
          if (likes.includes(currentUser.email)) {
            showError('You already liked this project');
            return;
          }
          
          // Add like
          likes.push(currentUser.email);
          await updateDoc(messageRef, { likes });
          
          // Add Sparks to creator
          if (messageData.userId && messageData.userId !== currentUser.email) {
            const creatorRef = doc(db, 'Kamba_users', messageData.userId);
            await updateDoc(creatorRef, {
              sparks: increment(2) // 2 Sparks per like
            });
            
            // Check for status upgrade
            await checkStatusUpgrade(messageData.userId);
          }
        }
      } catch (error) {
        console.error('Error liking project:', error);
        showError('Failed to like project. Please try again.');
      }
    }

    // Check if user should be upgraded to next status
    async function checkStatusUpgrade(userId) {
      const userRef = doc(db, 'Kamba_users', userId);
      const userSnap = await getDoc(userRef);
      
      if (userSnap.exists()) {
        const user = userSnap.data();
        let newStatus = user.accountStatus;
        
        if (user.sparks >= 1000 && user.accountStatus !== 'red') {
          newStatus = 'violet';
        } else if (user.sparks >= 100 && user.accountStatus === 'green') {
          newStatus = 'blue';
        }
        
        if (newStatus !== user.accountStatus) {
          await updateDoc(userRef, { accountStatus: newStatus });
        }
      }
    }

    // Firebase increment function
    function increment(value) {
      return {
        increment: value
      };
    }

    // Format timestamp
    function formatTimestamp(timestamp) {
      if (!timestamp) return 'Just now';
      
      const date = timestamp.toDate();
      const now = new Date();
      const diff = now - date;
      
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
      if (diff < 86400000) return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
    }

    // Open fullscreen image viewer
    function openFullscreenImage(url) {
      fullscreenImg.src = url;
      fullscreenViewer.style.display = 'flex';
    }

    // Download image
    function downloadImage(url) {
      const a = document.createElement('a');
      a.href = url;
      a.download = url.split('/').pop() || 'image';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Send message function
    async function sendMessage() {
      const text = sanitizeInput(messageInput.value.trim());
      if (!text && !uploadImageInput.files.length) return;

      showLoading();
      
      try {
        // Prepare images uploading
        let uploadedImageUrls = [];
        if (uploadImageInput.files.length > 0) {
          uploadedImageUrls = await uploadImages(uploadImageInput.files);
          if (uploadedImageUrls.length === 0 && !text) {
            showError('Please enter a message or select valid images.');
            return;
          }
        }

        // Create message doc
        const newMsg = {
          userId: currentUser.email,
          name: userData.name,
          text: text,
          timestamp: serverTimestamp(),
          accountStatus: userData.accountStatus || 'green',
          replyTo: replyToMessageId || null,
          replyToName: null,
          replyToText: null,
          images: uploadedImageUrls,
        };

        // If replying, fetch reply message info
        if (replyToMessageId) {
          const replyDoc = await getDoc(
            doc(db, 'servers', currentServer, 'channels', currentChannel, 'messages', replyToMessageId)
          );
          if (replyDoc.exists()) {
            const replyData = replyDoc.data();
            newMsg.replyToName = replyData.name || replyData.userId.split('@')[0];
            newMsg.replyToText = replyData.text || '';
          }
        }

        // Add message to Firestore
        await addDoc(
          collection(db, 'servers', currentServer, 'channels', currentChannel, 'messages'),
          newMsg
        );

        // Reset input
        messageInput.value = '';
        uploadImageInput.value = null;
        replyToMessageId = null;
        
        // Scroll to bottom
        scrollToBottom();
      } catch (error) {
        console.error('Error sending message:', error);
        showError('Failed to send message. Please try again.');
      } finally {
        hideLoading();
      }
    }

    // Upload images to Firebase Storage
    async function uploadImages(files) {
      let totalSize = 0;
      let uploadedUrls = [];
      
      try {
        for (const file of files) {
          totalSize += file.size;
          if (file.size > MAX_IMAGE_SIZE_MB * 1024 * 1024) {
            showError(`Image "${file.name}" exceeds ${MAX_IMAGE_SIZE_MB}MB size limit.`);
            continue;
          }
          if (totalSize > MAX_TOTAL_UPLOAD_MB * 1024 * 1024) {
            showError(`Total images size exceeds ${MAX_TOTAL_UPLOAD_MB}MB limit.`);
            break;
          }
          
          // Upload to Firebase Storage
          const storageRef = ref(storage, `chat_images/${currentUser.uid}/${Date.now()}_${file.name}`);
          await uploadBytes(storageRef, file);
          const downloadURL = await getDownloadURL(storageRef);
          uploadedUrls.push(downloadURL);
        }
        return uploadedUrls;
      } catch (err) {
        console.error('Image upload error:', err);
        showError('Image upload failed. Please try again.');
        return [];
      }
    }

    // Search functionality
    async function search(query) {
      if (!query || query.length < 2) return;
      
      showLoading();
      
      try {
        // Search users
        const usersQuery = query(
          collection(db, 'Kamba_users'),
          where('name', '>=', query),
          where('name', '<=', query + '\uf8ff')
        );
        
        // Search channels
        const channelsQuery = query(
          collection(db, 'servers', currentServer, 'channels'),
          where('name', '>=', query),
          where('name', '<=', query + '\uf8ff')
        );
        
        // Execute queries in parallel
        const [usersSnapshot, channelsSnapshot] = await Promise.all([
          getDocs(usersQuery),
          getDocs(channelsQuery)
        ]);
        
        // Process results
        const results = [];
        
        usersSnapshot.forEach(doc => {
          results.push({
            type: 'user',
            id: doc.id,
            ...doc.data()
          });
        });
        
        channelsSnapshot.forEach(doc => {
          results.push({
            type: 'channel',
            id: doc.id,
            ...doc.data()
          });
        });
        
        // Display results (in a real app, you would show these in a dropdown)
        console.log('Search results:', results);
        
      } catch (error) {
        console.error('Search error:', error);
        showError('Search failed. Please try again.');
      } finally {
        hideLoading();
      }
    }

    // Sanitize input to prevent XSS
    function sanitizeInput(input) {
      const div = document.createElement('div');
      div.textContent = input;
      return div.innerHTML;
    }

    // Show error message
    function showError(message) {
      const errorEl = document.createElement('div');
      errorEl.className = 'error-message';
      errorEl.textContent = message;
      chatMessages.appendChild(errorEl);
      setTimeout(() => errorEl.remove(), 5000);
    }

    // Show loading overlay
    function showLoading() {
      loadingOverlay.style.display = 'flex';
    }

    // Hide loading overlay
    function hideLoading() {
      loadingOverlay.style.display = 'none';
    }

    // Scroll chat to bottom
    function scrollToBottom() {
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Setup event listeners
    function setupEventListeners() {
      // Send message on Enter key
      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
        
        // Auto-resize textarea
        messageInput.style.height = 'auto';
        messageInput.style.height = (messageInput.scrollHeight) + 'px';
      });

      // Upload button triggers hidden file input
      uploadImageBtn.addEventListener('click', () => uploadImageInput.click());

      // Emoji picker toggle
      emojiBtn.addEventListener('click', toggleEmojiPicker);
      document.addEventListener('click', (e) => {
        if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
          emojiPicker.style.display = 'none';
        }
      });

      // Fullscreen image viewer
      fullscreenCloseBtn.addEventListener('click', () => {
        fullscreenViewer.style.display = 'none';
      });
      fullscreenViewer.addEventListener('click', (e) => {
        if (e.target === fullscreenViewer) {
          fullscreenViewer.style.display = 'none';
        }
      });

      // No song notification
      dismissNoSongBtn.addEventListener('click', () => {
        localStorage.setItem(NO_SONG_DISMISS_KEY, Date.now());
        noSongNotification.style.display = 'none';
      });
      setSongLink.addEventListener('click', (e) => {
        e.preventDefault();
        window.location.href = 'settings.html';
      });

      // Settings cog
      settingsCog.addEventListener('click', () => {
        window.location.href = 'settings.html';
      });

      // Search input
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        if (query.length > 1) {
          search(query);
        }
      });
    }

    // Toggle emoji picker
    function toggleEmojiPicker() {
      if (emojiPicker.style.display === 'flex') {
        emojiPicker.style.display = 'none';
      } else {
        emojiPicker.style.display = 'flex';
        if (!emojiPicker.hasChildNodes()) {
          emojis.forEach((e) => {
            const btn = document.createElement('button');
            btn.textContent = e;
            btn.title = e;
            btn.addEventListener('click', () => {
              messageInput.value += e;
              messageInput.focus();
            });
            emojiPicker.appendChild(btn);
          });
        }
      }
    }
  </script>
</body>
</html>
